프로그램 사용시 메모리 사용과 관련된 성능 및 최적화 문제를 다룰 때 유용하다.

1) MemoryMap: cs, ds, static, heap, stack --> PVM: Python Virtual Machine
cs(code segment) 코드영역: 프로그램의 소스코드가 저장되는 영역, 실행 가능한 명령어 집합
ds(data segment) 데이터 영역: 변수(전역, 정적)가 저장되는 영역, 프로그램 실행이 끝날 때 까지 유지
static 정적영역: &class, &function, &struct, &union, &static로 선언된 자료형 _선언과 동시에 주소가 생성
heap 동적할당 영역: 동적으로 메모리가 저장되는 영역,
                  프로그램일 실행시 다른 프로세스가 실행되지 않는 공간으로 할당했다가(동적할당)
                  실행이 끝나면 소거되는 영역(소멸)
stack 고정영역: 함수 호출과 관련된 임시 데이터가 저장되는 곳, 함수의 매개변수, 지역변수등 저장되는 영역

# 스택 힙 찾아보기 코드로 구현해보기 그만 놀아 ㅣㅅ발

******** PVM 크기, 메모리 용량, 코드크기, 런타임 모듈 확인
2) PVM : cs, ds, static, heap, stack (.py - > .pvc)
MemoryMap: cs, ds, static, heap, stack(. py -> .pyc) --> PVM: Python Virtual Machine
cs(code segment) 코드영역: 소스 코드가 바이트 코드로 컴파일 되어 로드 되는 곳
ds(data segment) 데이터 영역: 모듈에 선언된 변수가 저장
static 정적영역 ?: &class &static &function 으로 선언된 자료형은 heap에서 함께 관리된다.
heap 동적할당 영역: 파이썬의 자료형 객체가 할당되는 곳
stack 고정영역: 함수호출시 실행 컨텍스트가 저장되는 곳
=====================================================================================
3) PVM 언제 실행?
- python 인터프린터 실행: 쉘에서 python 입력하면 실행 -> PVM 초기화 _ 내장 모듈 임포트, 시스템 환경설정 ->
    바이트 코드 컴파일 -> 바이트 코드 실행 ->

어제한거 다시 람다고 바꾸라 과제 시봥ㅇㅇㅇㅇㅇㅇㅇㅇㅇㅇ-
=====================================================================================

 a_class.py 클래스 선언 방식 및, 호출
   클래스란? 사용자 자료형 = user datatype
   - 자주 사용하는 변수, 매소드등을 하나의 이름으로 등록하는 자료형
   - 속성 + 기능
   ex) a,b 라는 변수를 Test라는 나만의 자료형을 만들고  싶다.
   class Test: # 사용자 자료형 Test를 만들었다.
   int a
   int b
   [선언]

   name     kor     eng     mat
   홍길동      90     80      70
   정길동 50           60      70
   이길동      100 100 100
   class userName:
    변수, 메소드(생성자, 소멸자, 특수기능을 가진 추가 메소드등)
5) a_class02.py b_class02.pt --> __repr__ 메소드 재정의 및 self 개념
6) c_class.py 생성자

- 생성자랑 클래스 객체를 생성할 때 단 한번만 호출되는 메소드 __init__
- 생성자를 명시하지 않으면 매개인자 없는 기본 생성자가 자동으로 호출되어 객체가 생성된다.
- 생성자를 명시하면 명시된 생성자가 호출되고 명시하지 않으면 기본 생성자가 호출되어 객체가 생성된다.
- 생성자는 메소드 처럼 객체. 멤버로 호출되지 않는다.
- 생성자는 상송되지 않는다.

7) d_class.py
생성자의 기본 값을 전달해서 매개인자 유무에 따라 호출할 수 있는 하나의 생성자를 만들어서 객체를 생성해 보자.

8) e_class.py e_class 02.py -> Test(), Score() 객체 생성시 시퀀스로 변환 후 출력
- Packing : 여러값을 하나의 변수로 묶는 것 my_tuple= 10,10,30 ; my_list= 1,2,3]
- unpacking: 패킹된 값을 다시 개별 변수로 추출하는 것
                 a, b, c = my_tuple
                 x,y,z = my_list
======================================================

   name     kor     eng     mat
   홍길동      90     80      70
   정길동      50      60      70
   이길동      100     100        100


======================================================
클래스 재정의 메소드
1)__init__->None : 객체를 초기화 및 생성, 객체가 생성된 후 호출된다.(멤버변수 초기화, 설정 및 초기화)
        ex) def __init__(self):
            self.name = "noname"
2)__new__->Object : 객체 생성을 담당, 객체가 생성되기 전 호출된다.(객체간의 연산을 할때, 객체생성을 제어 및 수정)
    ex) def __new__(cls):
            res =super(Myclass, cls).__new__(cls)
            return res
            ex) t1= Test(100), t2= Test(200)   if t1=== t2:  ->객체가 가진 주소가 아닌 값으로 구현하고 싶을 때
            객체가 연산을 할때 사용되는 함수도 있고, __new__로 객체 제어도 한다.

            tip: __new__ 메소드를 객체 생성과정을 커스터마이즈 하고 사용자 정의 속성을 추가하면
            __init__메소드는 초기화 작업을 한다.

3)__repr__ -> str : 사용자가 이해하기 쉬운(정규화 출력, 서식 맞춘다.) 문자열로 리턴/ repr(obj)
--> 디버깅
4)__str__ -> str : 친화적인 문자열을 리턴 str(f'')또는 print()후 문자열을 리턴 --> 문자열로 리턴
            ====title====
            name,kor,eng,mat
